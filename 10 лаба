2


#include <iostream>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
// класс, представляющий издание (результат работы издательской компании) 
class publication
{
private:
	wstring title; // название издания
	float price; // цена экземпляра издания 
public:
	virtual void getdata()
	{
		wcout << L"\n введите название издания: "; getline(ws(wcin), title); 
		wcout << L" введите цену экземпляра издания: "; wcin >> price;
	}
	virtual void putdata() const
	{
		wcout << L"\n название издания: " << title;
		wcout << L"\n цена экземпляра издания: " << price << endl;
	}
};

// класс, представляющий бумажную книгу (производный от класса, представляющего издание)
class book : public publication
{
private:
	int pages; // количество страниц в книге 
public:
	void getdata()

	{
		publication::getdata();
		wcout << L" введите количество страниц в книге: "; wcin >> pages;
	}
	void putdata() const
	{
		publication::putdata();
		wcout << L" количество страниц в книге: " << pages << endl;
	}
};

// класс, представляющий аудиокнигу (производный от класса, представляющего издание)
class tape : public publication
{
private:
	float playing_time; // время проигрывания аудиокниги в минутах
public:
	void getdata()
	{
		publication::getdata();
		wcout << L" введите время проигрывания аудиокниги в минутах: "; wcin >> playing_time;
	}
		void putdata() const
	{
			publication::putdata();
			wcout << L" время проигрывания аудиокниги в минутах: " << playing_time << endl;
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	publication* pubPtr[100]; // массив указателей на объекты класса publication 
	int n = 0;	// количество действительно занятых элементов массива 
	wchar_t choice;		// символ, отражающий выбор пользователя

	// пользователь в цикле вводит данные изданий 
	do {
	wcout << L"Вводим бумажную или аудиокнигу? (б/а): "; wcin >> choice; if (choice == L'б')	// поместить новый объект-бумажную книгу
		pubPtr[n] = new book; //	в массив
	else		// поместить новый объект-аудиокассету
		pubPtr[n] = new tape; //	в массив
		wcout << L"Ввод данных издания " << n + 1 << L":";
		pubPtr[n++]->getdata(); // получим данные издания у пользователя
		wcout << L"\nВвести следующее издание? (y/n): "; wcin >> choice; wcout <<endl;

} while (choice == L'y'); // цикл выполняется, пока ответ «да»

// выведем на экран данные введенных выше изданий
for (int j = 0; j < n; j++)
	{
		wcout << L"Данные издания " << j + 1 << L":"; 
		pubPtr[j]->putdata();
	}

	return 0;
}




3



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
class Distance // длина в английской системе
{
private:
	int feet;	// футы 
	float inches; // дюймы
public:
	// конструктор без аргументов 
	Distance() : feet(0), inches(0.0)
{ }
// конструктор с одним аргументом (конвертирует float в Distance) 
	Distance(float fltfeet)
{
	feet = static_cast<int>(fltfeet); // футы — это целая часть fltfeet, 
	inches = 12 * (fltfeet - feet); // остальное — это дюймы
}
// конструктор с двумя аргументами 
Distance(int ft, float in) : feet(ft), inches(in)
{ }
void showdist() const // вывод полей на экран
{
	cout << feet << "\'-" << inches << '\"';
}
// перемножение двух длин (перегрузка бинарной операции умножения)
// (дружественная функция, не является членом класса) 
friend float operator* (Distance, Distance); // прототип
};

// перемножение двух длин (перегрузка бинарной операции умножения)
float operator* (Distance d1, Distance d2)
{
	return (d1.feet + d1.inches / 12) * (d2.feet + d2.inches / 12);
}

int main()
{
	setlocale(LC_ALL, "Russian");

	Distance dist1 = 2.5; // (для конвертации вещественных чисел в объекты класса 
	Distance dist2 = 1.25; // Distance используется конструктор с одним аргументом) 
	float Wdist; // для хранения результата перемножения двух объектов класса Distance

	// заданы два интервала в английских мерах длины, покажем их на экране 
	cout << "dist1 = "; dist1.showdist();
	cout << "\ndist2 = "; dist2.showdist();

	// перемножим два заданных интервала, меняя сомножители местами,
	// выведем результаты на экран 
	Wdist = dist1 * dist2;
	cout << "\n\ndist1 * dist2 = " << Wdist << " кв. футов";
	Wdist = dist2 * dist1;
	cout << "\ndist2 * dist1 = " << Wdist << " кв. футов";

	// рассмотрим случай, когда один из интервалов задан вещественным числом футов,
	// поменяем сомножители местами, выведем результаты на экран
	// (при этом вещественное число футов конвертируется в объект класса Distance
	// с помощью конструктора с одним аргументом) 
	Wdist = 7.5 * dist1;
	cout << "\n\n7.5 * dist1 = " << Wdist << " кв. футов"; Wdist = dist1 * 7.5;
	cout << "\ndist1 * 7.5 = " << Wdist << " кв. футов\n";

	return 0;
}





4




#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
class Array // класс, моделирующий обычный массив целых чисел
{
private:
	int* ptr; // указатель на содержимое массива 
	int size; // количество элементов в массиве
public:
	Array() : ptr(0), size(0)	// конструктор без аргументов
	{ }
	Array(int s)	// конструктор с одним аргументом
	{
		size = s;	// аргументом задается количество элементов в массиве 
		ptr = new int[s];		// память под массив
	}
	Array(Array& arr)	// перегруженный копирующий конструктор
	{
		size = arr.size;	// копируем количество элементов присваиваемого массива
		ptr = new int[size];		// выделим память под новый массив

		for (int i = 0; i < size; i++) // скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i); // в новый массив поэлементно
	}
	~Array()	// деструктор
	{
		delete[] ptr;
	}
	int& operator[] (int j)	// перегруженный оператор обращения к элементу массива
	{
		return *(ptr + j);
	}
	Array& operator= (Array& arr) // перегруженный оператор присваивания
	{
		// проверка на присваивание самому себе 
		if (this == &arr) return *this;
		delete[] ptr;	// освободим память, выделенную ранее под массив в конструкторе

		//   массива,   которому   присваиваем 4заданный массив
			size = arr.size;	// копируем количество элементов присваиваемого массива 
		ptr = new int[size];		// выделим память под новый массив
		for (int i = 0; i < size; i++) // скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i); // в новый массив поэлементно
		return *this;	// возвращает текущий объект
	}
	void display()	// вывод элементов массива на экран
	{
		for (int i = 0; i < size; i++)
			cout << *(ptr + i) << ' ';
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	const int ASIZE = 10; // количество элементов в массиве 
	Array arr1(ASIZE);	// создаем массив arr1

	for (int j = 0; j < ASIZE; j++) // заполним массив arr1 квадратами целых чисел, 
		arr1[j] = j * j;	// начав с нуля и двигаясь в положительную сторону

	// выведем на экран содержимое массива arr1 
		cout << "arr1 = "; arr1.display(); cout << endl;

	// тестируем копирующий конструктор
	Array arr2(arr1);

	// выведем на экран содержимое массива arr2 
		cout << "arr2 = "; arr2.display(); cout << endl;

	// тестируем операцию присваивания массивов 
		Array arr3(10), arr4(5), arr5(15);
		arr3 = arr1; // при равном количестве элементов
	arr4 = arr1; // количество элементов в присваиваемом массиве больше 
	arr5 = arr1; // количество элементов в присваиваемом массиве меньше
	// выведем на экран содержимое массивов arr3, arr4, arr5 
	cout << "arr3 = "; arr3.display(); cout << endl;
	cout << "arr4 = "; arr4.display(); cout << endl; 
	cout << "arr5 = "; arr5.display(); cout << endl;

	// тестируем присваивание самому себе 
	arr1 = arr1;
	// выведем на экран содержимое массива arr1 
	cout << "arr1 = "; arr1.display(); cout << endl;

	// тестируем множественное присваивание 
	Array arr6, arr7;
	arr7 = arr6 = arr1;
	// выведем на экран содержимое массивов arr6, arr7
	cout << "arr6 = "; arr6.display(); 
	cout << endl;
	cout << "arr7 = "; arr7.display(); cout << endl;

	return 0;
}





5





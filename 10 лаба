2


#include <iostream>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
// класс, представляющий издание (результат работы издательской компании) 
class publication
{
private:
	wstring title; // название издания
	float price; // цена экземпляра издания 
public:
	virtual void getdata()
	{
		wcout << L"\n введите название издания: "; getline(ws(wcin), title); 
		wcout << L" введите цену экземпляра издания: "; wcin >> price;
	}
	virtual void putdata() const
	{
		wcout << L"\n название издания: " << title;
		wcout << L"\n цена экземпляра издания: " << price << endl;
	}
};

// класс, представляющий бумажную книгу (производный от класса, представляющего издание)
class book : public publication
{
private:
	int pages; // количество страниц в книге 
public:
	void getdata()

	{
		publication::getdata();
		wcout << L" введите количество страниц в книге: "; wcin >> pages;
	}
	void putdata() const
	{
		publication::putdata();
		wcout << L" количество страниц в книге: " << pages << endl;
	}
};

// класс, представляющий аудиокнигу (производный от класса, представляющего издание)
class tape : public publication
{
private:
	float playing_time; // время проигрывания аудиокниги в минутах
public:
	void getdata()
	{
		publication::getdata();
		wcout << L" введите время проигрывания аудиокниги в минутах: "; wcin >> playing_time;
	}
		void putdata() const
	{
			publication::putdata();
			wcout << L" время проигрывания аудиокниги в минутах: " << playing_time << endl;
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	publication* pubPtr[100]; // массив указателей на объекты класса publication 
	int n = 0;	// количество действительно занятых элементов массива 
	wchar_t choice;		// символ, отражающий выбор пользователя

	// пользователь в цикле вводит данные изданий 
	do {
	wcout << L"Вводим бумажную или аудиокнигу? (б/а): "; wcin >> choice; if (choice == L'б')	// поместить новый объект-бумажную книгу
		pubPtr[n] = new book; //	в массив
	else		// поместить новый объект-аудиокассету
		pubPtr[n] = new tape; //	в массив
		wcout << L"Ввод данных издания " << n + 1 << L":";
		pubPtr[n++]->getdata(); // получим данные издания у пользователя
		wcout << L"\nВвести следующее издание? (y/n): "; wcin >> choice; wcout <<endl;

} while (choice == L'y'); // цикл выполняется, пока ответ «да»

// выведем на экран данные введенных выше изданий
for (int j = 0; j < n; j++)
	{
		wcout << L"Данные издания " << j + 1 << L":"; 
		pubPtr[j]->putdata();
	}

	return 0;
}




3



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
class Distance // длина в английской системе
{
private:
	int feet;	// футы 
	float inches; // дюймы
public:
	// конструктор без аргументов 
	Distance() : feet(0), inches(0.0)
{ }
// конструктор с одним аргументом (конвертирует float в Distance) 
	Distance(float fltfeet)
{
	feet = static_cast<int>(fltfeet); // футы — это целая часть fltfeet, 
	inches = 12 * (fltfeet - feet); // остальное — это дюймы
}
// конструктор с двумя аргументами 
Distance(int ft, float in) : feet(ft), inches(in)
{ }
void showdist() const // вывод полей на экран
{
	cout << feet << "\'-" << inches << '\"';
}
// перемножение двух длин (перегрузка бинарной операции умножения)
// (дружественная функция, не является членом класса) 
friend float operator* (Distance, Distance); // прототип
};

// перемножение двух длин (перегрузка бинарной операции умножения)
float operator* (Distance d1, Distance d2)
{
	return (d1.feet + d1.inches / 12) * (d2.feet + d2.inches / 12);
}

int main()
{
	setlocale(LC_ALL, "Russian");

	Distance dist1 = 2.5; // (для конвертации вещественных чисел в объекты класса 
	Distance dist2 = 1.25; // Distance используется конструктор с одним аргументом) 
	float Wdist; // для хранения результата перемножения двух объектов класса Distance

	// заданы два интервала в английских мерах длины, покажем их на экране 
	cout << "dist1 = "; dist1.showdist();
	cout << "\ndist2 = "; dist2.showdist();

	// перемножим два заданных интервала, меняя сомножители местами,
	// выведем результаты на экран 
	Wdist = dist1 * dist2;
	cout << "\n\ndist1 * dist2 = " << Wdist << " кв. футов";
	Wdist = dist2 * dist1;
	cout << "\ndist2 * dist1 = " << Wdist << " кв. футов";

	// рассмотрим случай, когда один из интервалов задан вещественным числом футов,
	// поменяем сомножители местами, выведем результаты на экран
	// (при этом вещественное число футов конвертируется в объект класса Distance
	// с помощью конструктора с одним аргументом) 
	Wdist = 7.5 * dist1;
	cout << "\n\n7.5 * dist1 = " << Wdist << " кв. футов"; Wdist = dist1 * 7.5;
	cout << "\ndist1 * 7.5 = " << Wdist << " кв. футов\n";

	return 0;
}





4




#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
class Array // класс, моделирующий обычный массив целых чисел
{
private:
	int* ptr; // указатель на содержимое массива 
	int size; // количество элементов в массиве
public:
	Array() : ptr(0), size(0)	// конструктор без аргументов
	{ }
	Array(int s)	// конструктор с одним аргументом
	{
		size = s;	// аргументом задается количество элементов в массиве 
		ptr = new int[s];		// память под массив
	}
	Array(Array& arr)	// перегруженный копирующий конструктор
	{
		size = arr.size;	// копируем количество элементов присваиваемого массива
		ptr = new int[size];		// выделим память под новый массив

		for (int i = 0; i < size; i++) // скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i); // в новый массив поэлементно
	}
	~Array()	// деструктор
	{
		delete[] ptr;
	}
	int& operator[] (int j)	// перегруженный оператор обращения к элементу массива
	{
		return *(ptr + j);
	}
	Array& operator= (Array& arr) // перегруженный оператор присваивания
	{
		// проверка на присваивание самому себе 
		if (this == &arr) return *this;
		delete[] ptr;	// освободим память, выделенную ранее под массив в конструкторе

		//   массива,   которому   присваиваем 4заданный массив
			size = arr.size;	// копируем количество элементов присваиваемого массива 
		ptr = new int[size];		// выделим память под новый массив
		for (int i = 0; i < size; i++) // скопируем заданный аргументом массив
			*(ptr + i) = *(arr.ptr + i); // в новый массив поэлементно
		return *this;	// возвращает текущий объект
	}
	void display()	// вывод элементов массива на экран
	{
		for (int i = 0; i < size; i++)
			cout << *(ptr + i) << ' ';
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	const int ASIZE = 10; // количество элементов в массиве 
	Array arr1(ASIZE);	// создаем массив arr1

	for (int j = 0; j < ASIZE; j++) // заполним массив arr1 квадратами целых чисел, 
		arr1[j] = j * j;	// начав с нуля и двигаясь в положительную сторону

	// выведем на экран содержимое массива arr1 
		cout << "arr1 = "; arr1.display(); cout << endl;

	// тестируем копирующий конструктор
	Array arr2(arr1);

	// выведем на экран содержимое массива arr2 
		cout << "arr2 = "; arr2.display(); cout << endl;

	// тестируем операцию присваивания массивов 
		Array arr3(10), arr4(5), arr5(15);
		arr3 = arr1; // при равном количестве элементов
	arr4 = arr1; // количество элементов в присваиваемом массиве больше 
	arr5 = arr1; // количество элементов в присваиваемом массиве меньше
	// выведем на экран содержимое массивов arr3, arr4, arr5 
	cout << "arr3 = "; arr3.display(); cout << endl;
	cout << "arr4 = "; arr4.display(); cout << endl; 
	cout << "arr5 = "; arr5.display(); cout << endl;

	// тестируем присваивание самому себе 
	arr1 = arr1;
	// выведем на экран содержимое массива arr1 
	cout << "arr1 = "; arr1.display(); cout << endl;

	// тестируем множественное присваивание 
	Array arr6, arr7;
	arr7 = arr6 = arr1;
	// выведем на экран содержимое массивов arr6, arr7
	cout << "arr6 = "; arr6.display(); 
	cout << endl;
	cout << "arr7 = "; arr7.display(); cout << endl;

	return 0;
}





5




#include <iostream>
#include <iomanip>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
// класс, представляющий издание (результат работы издательской компании) 
class publication
{
private:
	wstring title; // название издания
	float price; // цена экземпляра издания
public:
	virtual void getdata()
	{
		// Для получения названия издания используем функцию getline, чтобы
		// можно было вводить названия из нескольких слов (с пробелами), хотя
		// задание этого и не требует.

		// При вводе нескольких объектов функция getline при вводе второго
		// объекта будет использоваться после оператора извлечения (>>)
		// числа из потока wcin предыдущего объекта. При этом после оператора
		// извлечения (>>) в потоке wcin останется символ L'\n', из-за чего
		// не получится ввести название издания для второго объекта.
		// Чтобы избежать этой ситуации, используем функцию ws, которая удаляет

		// ведущие пробельные символы из входящего потока wcin.

		wcout << L"\n введите название издания: "; getline(ws(wcin), title); 
		wcout << L" введите цену экземпляра издания: "; wcin >> price;
	}
	virtual void putdata() const
	{
		wcout << L"\n название издания: " << title;
		wcout << L"\n цена экземпляра издания: " << price << endl;
	}
	virtual bool isOversize() const = 0; // чистый виртуальный метод
};

// класс, представляющий бумажную книгу (производный от класса, представляющего издание)
class book : public publication
{
private:
	int pages; // количество страниц в книге
public:
	void getdata()
	{
		publication::getdata();
		wcout << L" введите количество страниц в книге: "; wcin >> pages;
	}
	void putdata() const
	{
		publication::putdata();
		wcout << L" количество страниц в книге: " << pages << endl;
	}
	// с помощью этого метода можно определить, не слишком ли большой размер у книги
	bool isOversize() const
	{
		if (pages > 800) // размер книги считается слишком большим, если количество
			return true; // страниц в ней больше 800

		else
			return false;
	}
};





// класс, представляющий аудиокнигу (производный от класса, представляющего издание)
class tape : public publication
{
private:
	float playing_time; // время проигрывания аудиокниги в минутах
public:
	void getdata()
	{
		publication::getdata();

		wcout << L" введите время проигрывания аудиокниги в минутах: "; wcin >> playing_time;
	}
	void putdata() const
	{
		publication::putdata();
		wcout << L" время проигрывания аудиокниги в минутах: " << playing_time << endl;
	}
// с помощью этого метода можно определить, не слишком ли большая длительность у аудиокниги
		bool isOversize() const
	{
			if (playing_time > 90) // длительность аудиокниги считается слишком большой, если

				return true;	// время ее проигрывания больше 90 минут,
			else		// то есть она занимает больше двух 45-минутных аудиокассет 
				return false;
	}
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	publication* pubPtr[100]; // массив указателей на объекты класса publication 
	int n = 0;	// количество действительно занятых элементов массива 
	wchar_t choice;		// символ, отражающий выбор пользователя

	// пользователь в цикле вводит данные изданий
	do {
		wcout << L"Вводим бумажную или аудиокнигу? (б/а): "; wcin >> choice; if (choice == L'б')	// поместить новый объект-бумажную книгу
			pubPtr[n] = new book; //	в массив
		else		// поместить новый объект-аудиокассету 
			pubPtr[n] = new tape; //	в массив
		wcout << L"Ввод данных издания " << n + 1 << L":";
		pubPtr[n++]->getdata(); // получим данные издания у пользователя
		wcout << L"\nВвести следующее издание? (д/н): "; wcin >> choice; wcout << endl;



} while (choice == L'д'); // цикл выполняется, пока ответ «да»

// выведем на экран данные введенных выше изданий
	for (int j = 0; j < n; j++)
	{

		wcout << L"Данные издания " << j + 1 << L":"; 
		pubPtr[j]->putdata();

		// если издание слишком большого размера, выведем соответствующую пометку
		if (pubPtr[j]->isOversize()) wcout << L" (слишком большого размера!)\n";
	}

	return 0;
}






6





#include <iostream>
#include <iomanip> // для манипуляторов setiosflags, setprecision
#include <sstream> // для стандартного класса wstringstream 
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
class bMoney // класс, представляющий денежную сумму в долларах и центах
{
private:
	long double sum; // денежная сумма в долларах и центах
public:
	bMoney() // конструктор без параметров
	{
		sum = 0.0;
	}
	// конструктор с одним параметром (преобразование из long double в bMoney)
	// (с помощью служебного слова explicit делаем возможным использование
	// конструктора только в виде конструктора, а не для неявных преобразований)
	explicit bMoney(long double n) : sum(n)
	{ }
	bMoney(const wchar_t s[]) // конструктор с одним параметром (денежная строка)
	{
		mstold(s);
	}
	// метод преобразует денежную строку в число типа long double 
	long double mstold(const wchar_t[]); // прототип
	// метод преобразует число типа long double (sum) в денежную строку и
	// возвращает эту строку через первый параметр 
	void ldtoms(wchar_t[]); // прототип
	// метод для получения денежной строки от пользователя с клавиатуры
	// и сохранения ее в поле sum класса 
	void getmoney()
	{
		setlocale(LC_ALL, "Russian");
		wchar_t tms[80]; // для строки с денежной суммой
		cout << "Введите денежную сумму (пример: '$1,234,567.99'):\n"; wcin >> tms; // получаем денежную строку
		mstold(tms); // преобразуем денежную строку в long double и сохраняем в sum
	}
// метод для вывода поля sum класса на экран в виде денежной строки 
	void putmoney()
	{
		wchar_t tms[80]; // для строки с денежной суммой
		ldtoms(tms);		// преобразуем поле sum класса (long double) в денежную строку
		cout << tms;	// выводим денежную строку на экран
	}
	// операция сложения двух объектов класса
	 bMoney operator+ (bMoney m) const
	// используем конструктор с одним параметром для преобразования long double в bMoney
	{
		 return bMoney(sum + m.sum);
	}

	// операция нахождения разности двух объектов класса 
	 bMoney operator- (bMoney m) const
	{
		return bMoney(sum - m.sum);
	}
	// операция нахождения произведения объекта класса и числа типа long double 
	 bMoney operator* (long double n) const
	{
		return bMoney(sum * n);
	}
	// операция нахождения частного от деления объекта класса на другой объект класса 
	 long double operator/ (bMoney m) const
	{
		return sum / m.sum;
	}
// операция нахождения частного от деления объекта класса на число типа long double
bMoney operator/ (long double n) const
	{
		return bMoney(sum / n);
	}
	// дружественный для класса bMoney оператор для обработки выражений вида long double * bMoney
	friend bMoney operator* (long double, bMoney); // прототип
	// дружественный для класса bMoney оператор для обработки выражений вида long double / bMoney
	friend long double operator/ (long double, bMoney); // прототип
};

int main()
{

	wchar_t ans;	// для ответа пользователя о продолжении ввода (д/н) 
	bMoney m1, m2, mres; // для двух денежных сумм и результата операций 
	long double n, res; // для вещественного числа и результата операций
// работаем в цикле, чтобы можно было выполнить операции для разных исходных данных
do {
// запрашиваем у пользователя исходные данные 
	cout << "1. "; m1.getmoney();
			cout << "2. "; m2.getmoney();
			cout << "3. Введите вещественное число: "; cin >> n; cout << endl;
// выполняем пять перегруженных операций и выводим результаты на 	экран

				mres = m1 + m2; cout << "1. m1 + m2 = "; mres.putmoney(); cout << endl;
				mres = m1 - m2; cout << "2. m1 - m2 = ";mres.putmoney(); cout << endl; 
				mres = m1 * n; cout << "3. m1 * n = ";mres.putmoney(); cout << endl;
				res = m1 / m2; cout << "4. m1 / m2 = " << res << endl;
			mres = m1 / n; cout << "5. m1 / n = "; mres.putmoney(); cout << endl;


			// на описанные ниже две закомментированные операции компилятор должен выдавать ошибку
			// (они не имеют смысла в рамках концепции класса bMoney, представляющего денежную сумму)
// нет смысла в произведении денежных сумм:
				// например, если 5 м * 20 м = 100 кв.м., где 100 кв.м. — это площадь прямоугольника,
				// то 5 руб. * 20 руб. = 100 кв.руб. — нет сущностей, измеряющихся в квадратных рублях!
				// mres = m1 * m2; // Операция умножения с такими типами операндов не определена в классе bMoney.
			// Конечно, можно ее определить, но нам этого не нужно.
			// Также можно определить операцию преобразования bMoney в long double, // но нам этого тоже не нужно.
			// нет смысла в сложении денежной суммы (к примеру, стоимости деталей) и числа(деталей)
// mres = m1 + n; // Операция сложения с такими типами операндов не определена в классе bMoney.
			// Если убрать служебное слово explicit из заголовка конструктора с одним будет работать, но нам этого не нужно.
// параметром, то данное выражение

				// на описанные ниже две закомментированные операции компилятор уже не выдает ошибку,
				// так как были написаны соответствующие перегружающие дружественные операции
			// это просто перемена сомножителей в работающей выше операции mres = m1* n;
// она бы работала без написания отдельной дружественной операции, если б были определены
				// операции преобразования bMoney <-> long double, но по условиям задания операции
// преобразования должны быть отключены
				mres = n * m1; cout << "6. n * m1 = "; mres.putmoney(); cout << endl;

			// Непонятно, какой смысл у этой операции (какой смысл в делении, к примеру, количества
			// деталей на некую денежную сумму?). Будем считать, что подразумевается, что n — это
			// тоже денежная сумма, только в виде вещественного числа, а не объекта класса bMoney.
				// Тогда отдельная для этой операции дружественная функция должна делать то же, что и
				// перегруженная операция bMoney / bMoney = long double. 
				res = n / m1;  cout << "7. n / m1 = " << res << endl << endl;

				cout << "Попробовать с другими исходными данными (д/н)? "; wcin >> ans;
			cout << endl;
		} while (ans != 'н');

		return 0;
}

// дружественный для класса bMoney оператор для обработки выражений вида long double * bMoney
bMoney operator* (long double n, bMoney m)
{
	return bMoney(n * m.sum);
}

// дружественный для класса bMoney оператор для обработки выражений вида long double / bMoney
long double operator/ (long double n, bMoney m)
{
	return n / m.sum;
}

// метод преобразует заданную строку в число типа long double и возвращает это число;
// предполагается, что заданная строка представляет денежную сумму,
// например, "$1,234,567,890,123.99";
// mstold расшифровывается как "money string to long double" 
long double bMoney::mstold(const wchar_t str[])
{
	wchar_t temp[80]; // временная строка
	int j = 0;	// индекс для временной строки (массива символов)
	// обрабатываем денежную строку-параметр как массив символов 
	for (int i = 0; i < wcslen(str); i++)
	{
		wchar_t ch = str[i]; // возьмем очередной символ из массива (строки)

		if ((ch >= '0') && (ch <= '9')) // если он является цифрой,
			temp[j++] = ch;		// то добавить его к временной строке, 
		else if (ch == '.')	// иначе, если он является точкой,

		temp[j++] = ch;	// то тоже добавить к временной строке,
		//остальные символы игнорировать
	}
	temp[j] = '\0'; // завершаем временную строку нулевым символом

	wchar_t* stop;
	// преобразуем временную строку в числовое значение типа long double 
	sum = wcstold(temp, &stop);
	// В книге Лафоре рекомендует использовать библиотечную функцию _atold для
	// преобразования строки в виде массива типа char в число типа long double.
	// Однако, нужно учитывать, что Лафоре пользовался при написании книги
	// средой Microsoft Visual C++ версии 6.0, вышедшей в 1998 году.
	// На сегодня (2019 год) в среде Visual Studio Community 2017 библиотечная функция
// _atold отсутствует.

		// Есть функция atof, принимающая в качестве аргумента массив типа char, но
		// она возвращает число типа double, а не long double.

		// Еще есть функция _atoldbl, которая принимает вторым аргументом массив типа
		// char и возвращает в первом аргументе значение типа указатель на _ DOUB E.

		// Еще есть функция strtold, которая принимает первым аргументом массив типа
		// char и возвращает число типа long double. Ее аналогом для широких символов
		// является функция wcstold.

		// Для преобразования массива типа wchar_t (широких символов) я нашел и
		// применил (см. выше) библиотечную функцию wcstold. Эта функция принимает
		// массив типа wchar_t первым аргументом и возвращает соответствующее число
		// типа long double. Второй параметр обязателен, но для наших целей НЕ
		// ИМЕЕТ ЗНАЧЕНИЯ (в нем возвращается адрес первого символа в строке
		// такого, что не может являться частью числа). Для понимания второго
		// параметра нужно понимание указателей, которые будут разбираться позже,
		// в девятой главе книги.


		// Ну и ВАЖНО понимать, что тип long double поддерживался как 80-битное представление
		// числа с плавающей запятой только в старых версиях Microsoft Visual C++.
		// В последних версиях, в том числе и в Visual Studio Community 2017, тип
		// long double хоть и поддерживается и отличается компилятором от типа double,
		// однако, на деле является таким же 64-битным представлением числа с плавающей
		// запятой, как и double. Эти типы в указанной среде разработки идентичны и
		// значения таких типов занимают по 8 байт (64 бита) каждое.

		// Размер 8 байт (64 бита) позволяет оперировать числами длиной в 15-16 значимых
		// десятичных разрядов (включая разряды после десятичной точки). То есть, к примеру,
		// получив на вход строку "$123,456,789,012,345.62" наш метод mstold вернет
		// число типа long double = 123456789012345.63

		// Из этого примера видно, что в последнем, 17-м разряде, вместо цифры "2" стоит
		// цифра "3". То есть ручаться можно только за точность первых 15-16 разрядов.

		return sum; // возвращаем полученное значение
}

// метод преобразует число типа long double (поле sum класса bMoney) в денежную строку
// и возвращает эту строку через первый параметр 
void bMoney::ldtoms(wchar_t str[])
{
	// В условиях упражнения в книге сказано, что при преобразовании числа в строку
		// можно использовать объект класса ostrstream "как рассматривалось ранее в этой главе". книги.
// На самом деле в главе 7, к которой идет это упражнение, и ранее Лафоре ничего
		// не писал об этом. Автор перепутал с 12-й главой, а конкретнее — см. стр.585
// Итак, объект класса ostrstream можно здесь рассматривать как аналог стандартных
		// потоков ввода и вывода cin и cout. Для его использования нужно включить в программу
		// заголовочный файл <strstream>. Однако, нужно учитывать, что использование класса
		// ostrstream не одобряется, начиная со стандарта C++98.

		// Вместо класса ostrstream стандарт языка C++ рекомендует использовать ostringstream,
		// который требует включения в программу заголовочного файла <sstream>. Обакласса
		// (ostrstream и ostringstream) работают со строками-массивами типа char. Дляшироких
		// символов типа wchar_t можно использовать класс wostringstream, тоже требующий включения
		// в программу заголовочного файла <sstream>.

		// Вместо wostringstream я взяла класс wstringstream, с объектом которого можно использовать
		// и вывод (оператор вставки), и ввод (оператор извлечения из потока).

		wchar_t ustring[80]; // временная строка
	wstringstream woss; // создадим объект стандартного класса wstringstream

	// преобразуем число sum типа long double в строку, указав, что нужен неэкспоненциальный
	// вид числа и количество знаков после десятичной точки должно быть 2 
	woss << setiosflags(ios::fixed) << setprecision(2) << sum;
	// загрузим полученную строку из потока во временную строку 
	woss >> ustring;

	int i = 0, n = 0, j;	// индексы строк str и ustring соответственно
	int len = wcslen(ustring); // длина временной строки ustring
	wchar_t delim3 = ',';	// символ, разделяющий тройки разрядов (разделитель)

	str[i++] = '$'; // первым в денежной строке идет символ доллара

	// выражение (len - 3) означает количество знаков числа
	// без десятичной точки и двух разрядов после точки

	if (len > 6) // если в числе требуются разделители
	{
		if ((len - 3) % 3 == 2)	// если старших разрядов до разделителя два,
		{
			str[i++] = ustring[n++]; // то переписать два старших разряда 
			str[i++] = ustring[n++];
			str[i++] = delim3;	// и вписать разделитель
		}


		else if ((len - 3) % 3 == 1) // иначе, если старший разряд до разделителя один,
		{
			str[i++] = ustring[n++]; // то переписать старший разряд 
			str[i++] = delim3;	// и вписать разделитель

		}
	}

	for (j = n; j < len - 3; j++) // переберем оставшиеся символы в цикле
	{
		str[i++] = ustring[j];	// перепишем очередной разряд
		// после каждой тройки разрядов вставляем разделитель, если
		// только это не последняя тройка разрядов 
		if (((j - n + 1) % 3 == 0) && (j != len - 3 - 1))
		str[i++] = delim3;
	}

	str[i++] = ustring[j++]; // перепишем точку и два
	str[i++] = ustring[j++]; // разряда после точки (центы) 
	str[i++] = ustring[j];
	str[i] = '\0';	// последним вписываем нулевой символ
}





7




#include <iostream>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <iomanip> // для манипуляторов setiosflags, setprecision
#include <sstream> // для стандартного класса wstringstream 
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

class bMoney // класс, представляющий денежную сумму в долларах и центах
{
private:
	long double sum; // денежная сумма в долларах и центах 
public:
	bMoney() // конструктор без параметров
	{
sum = 0.0L;
	}
	// конструктор с одним параметром (преобразование из long double в bMoney)
	// (с помощью служебного слова explicit делаем возможным использование
	// конструктора только в виде конструктора, а не для неявных преобразований) 
	explicit bMoney(long double n) : sum(n)
	{ }
	bMoney(const wchar_t s[]) // конструктор с одним параметром (денежная строка)
	{
		mstold(s);
	}
	// метод преобразует денежную строку в число типа long double
	long double mstold(const wchar_t[]); // прототип
	// метод преобразует число типа long double (sum) в денежную строку и
	// возвращает эту строку через первый параметр 
	void ldtoms(wchar_t[]); // прототип
	// метод для получения денежной строки от пользователя с клавиатуры
	// и сохранения ее в поле sum класса 
	void getmoney()
	{
		wchar_t tms[80]; // для строки с денежной суммой
		wcout << L"Введите денежную сумму (пример: '$1,234,567.99'):\n"; wcin >> tms; // получаем денежную строку
		mstold(tms); // преобразуем денежную строку в long double и сохраняем в sum
	}
	// метод для вывода поля sum класса на экран в виде денежной строки 
	void putmoney()
	{
		wchar_t tms[80]; // для строки с денежной суммой
		ldtoms(tms);	// преобразуем поле sum класса (long double) в денежную строку
		wcout << tms;		// выводим денежную строку на экран
	}
	// операция сложения двух объектов класса
	 bMoney operator+ (bMoney m) const
	// используем конструктор с одним параметром для преобразования long double в bMoney
	{
		 return bMoney(sum + m.sum);

	}

// операция нахождения разности двух объектов класса
	 bMoney operator- (bMoney m) const
	{
		return bMoney(sum - m.sum);
	}
	// операция нахождения произведения объекта класса и числа типа long double 
	 bMoney operator* (long double n) const
	{
		return bMoney(sum * n);
	}
	// операция нахождения частного от деления объекта класса на другой объект класса 
	 long double operator/ (bMoney m) const
	{
		return sum / m.sum;
	}
	// операция нахождения частного от деления объекта класса на число типа long double 
	 bMoney operator/ (long double n) const
	{
		return bMoney(sum / n);
	}
	// дружественный для класса bMoney оператор для обработки выражений вида long double * bMoney
	friend bMoney operator* (long double, bMoney); // прототип
	// дружественный для класса bMoney оператор для обработки выражений вида long double / bMoney
	friend long double operator/ (long double, bMoney); // прототип
	// дружественная для класса bMoney функция для округления денежной строки до долларов
	friend bMoney round(bMoney); // прототип
};

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT); bMoney mo1, mo2;
	// тестируем округление «вниз»
	mo1 = L"$1,234,567.23";		// задаем значение
	mo1.putmoney(); wcout << L" -> "; // и выводим его на экран
	mo2 = round(mo1);	// округляем до долларов
	mo2.putmoney(); wcout << endl;	// выводим результат округления на экран

	// тестируем округление «вверх»
	mo1 = L"$1,234,567.50";		// задаем значение 
	mo1.putmoney(); wcout << L" -> "; // и выводим его на экран 
	mo2 = round(mo1);	// округляем до долларов
	mo2.putmoney(); wcout << endl;	// выводим результат округления на экран

	// результат работы программы должен быть такой:
	// $1,234,567.23 -> $1,234,567.00
	// $1,234,567.50 -> $1,234,568.00

	// как мы видим, результаты округлений первого и второго заданных значений
	// отличаются на единицу

	return 0;
}

// дружественный для класса bMoney оператор для обработки выражений вида long double * bMoney
bMoney operator* (long double n, bMoney m)

{
	return bMoney(n * m.sum);
}

// дружественный для класса bMoney оператор для обработки выражений вида long double / bMoney
long double operator/ (long double n, bMoney m)
{
	return n / m.sum;
}

// дружественная для класса bMoney функция для округления денежной строки до долларов
bMoney round(bMoney m)
{
	long double i, f;	// для целой и дробной части денежной строки
	f = modfl(m.sum, &i); // с помощью библиотечной функции modfl разделяем целую и дробную
	//   части   денежной   строки   и   помещаем   их   в переменные i и f
		if (f < 0.50L)
			return bMoney(i);
else

return bMoney(i + 1.0L);
}
// метод преобразует заданную строку в число типа long double и возвращает это число;
// предполагается, что заданная строка представляет денежную сумму,
// например, "$1,234,567,890,123.99";
// mstold расшифровывается как "money string to long double" 
long double bMoney::mstold(const wchar_t str[])
{
	wchar_t temp[80]; // временная строка
	int j = 0;	// индекс для временной строки (массива символов)
	// обрабатываем денежную строку-параметр как массив символов 
	for (int i = 0; i < wcslen(str); i++)
	{
		wchar_t ch = str[i]; // возьмем очередной символ из массива (строки)
		if ((ch >= L'0') && (ch <= L'9')) // если он является цифрой,
			temp[j++] = ch;		// то добавить его к временной строке, 
		else if (ch == L'.')	// иначе, если он является точкой,
		temp[j++] = ch;	// то тоже добавить к временной строке,
		// остальные символы игнорировать
	}
temp[j] = L'\0'; // завершаем временную строку нулевым символом

	wchar_t* stop;
	// преобразуем временную строку в числовое значение типа long double
	sum = wcstold(temp, &stop);

	// В книге Лафоре рекомендует использовать библиотечную функцию _atold для
	// преобразования строки в виде массива типа char в число типа long double.
	// Однако, нужно учитывать, что Лафоре пользовался при написании книги
	// средой Microsoft Visual C++ версии 6.0, вышедшей в 1998 году.
	// На сегодня (2019 год) в среде Visual Studio Community 2017 библиотечная функция
	// _atold отсутствует.

	// Есть функция atof, принимающая в качестве аргумента массив типа char, но
	// она возвращает число типа double, а не long double.

	// Еще есть функция _atoldbl, которая принимает вторым аргументом массив типа
	// char и возвращает в первом аргументе значение типа указатель на _LDOUBLE.

	// Еще есть функция strtold, которая принимает первым аргументом массив типа
	// char и возвращает число типа long double. Ее аналогом для широких символов
	// является функция wcstold.

	// Для преобразования массива типа wchar_t (широких символов) я нашел и
	// применил (см. выше) библиотечную функцию wcstold. Эта функция принимает
	// массив типа wchar_t первым аргументом и возвращает соответствующее число
	// типа long double. Второй параметр обязателен, но для наших целей НЕ
	// ИМЕЕТ ЗНАЧЕНИЯ (в нем возвращается адрес первого символа в строке
	// такого, что не может являться частью числа). Для понимания второго
	// параметра нужно понимание указателей, которые будут разбираться позже,
	// в девятой главе книги.

	// Ну и ВАЖНО понимать, что тип long double поддерживался как 80-битное представление
	// числа с плавающей запятой только в старых версиях Microsoft Visual C++.
	// В последних версиях, в том числе и в Visual Studio Community 2017, тип
	// long double хоть и поддерживается и отличается компилятором от типа double,
	// однако, на деле является таким же 64-битным представлением числа с плавающей
	// запятой, как и double. Эти типы в указанной среде разработки идентичны и
	// значения таких типов занимают по 8 байт (64 бита) каждое.

	// Размер 8 байт (64 бита) позволяет оперировать числами длиной в 15-16 значимых
	// десятичных разрядов (включая разряды после десятичной точки). То есть, к примеру,
	// получив на вход строку "$123,456,789,012,345.62" наш метод mstold вернет
	// число типа long double = 123456789012345.63
	// Из этого примера видно, что в последнем, 17-м разряде, вместо цифры "2" стоит
	// цифра "3". То есть ручаться можно только за точность первых 15-16 разрядов.

	return sum; // возвращаем полученное значение
}

// метод преобразует число типа long double (поле sum класса bMoney) в денежную строку
// и возвращает эту строку через первый параметр
void bMoney::ldtoms(wchar_t str[])

{

	wchar_t ustring[80]; // временная строка
	wstringstream woss; // создадим объект стандартного класса wstringstream

	//	преобразуем	число	sum	типа	long	double	в	строку,	указав,	что	нужен неэкспоненциальный
	// вид числа и количество знаков после десятичной точки должно быть 2
	woss << setiosflags(ios::fixed) << setprecision(2) << sum;
	// загрузим полученную строку из потока во временную строку
	woss >> ustring;

	int i = 0, n = 0, j;	// индексы строк str и ustring соответственно 
	int len = wcslen(ustring); // длина временной строки ustring
	wchar_t delim3 = L',';	// символ, разделяющий тройки разрядов (разделитель)
	str[i++] = L'$'; // первым в денежной строке идет символ доллара
	// выражение (len - 3) означает количество знаков числа
	// без десятичной точки и двух разрядов после точки

	if (len > 6) // если в числе требуются разделители
	{
		if ((len - 3) % 3 == 2)	// если старших разрядов до разделителя два,
		{
			str[i++] = ustring[n++]; // то переписать два старших разряда 
			str[i++] = ustring[n++];
			str[i++] = delim3;	// и вписать разделитель
		}
		else if ((len - 3) % 3 == 1) // иначе, если старший разряд до разделителя один,
		{
			str[i++] = ustring[n++]; // то переписать старший разряд 
			str[i++] = delim3;	// и вписать разделитель
		}
	}

	for (j = n; j < len - 3; j++) // переберем оставшиеся символы в цикле
	{
		str[i++] = ustring[j];	// перепишем очередной разряд
		// после каждой тройки разрядов вставляем разделитель, если
		// только это не последняя тройка разрядов
		if (((j - n + 1) % 3 == 0) && (j != len - 3 - 1))
		str[i++] = delim3;
	}

	str[i++] = ustring[j++]; // перепишем точку и два
	str[i++] = ustring[j++]; // разряда после точки (центы) 
	str[i++] = ustring[j];
	str[i] = L'\0';	// последним вписываем нулевой символ
}





8 и 9



#include <iostream>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <iomanip> // для манипуляторов setiosflags, setprecision
#include <sstream> // для стандартного класса wstringstream 
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

class Token // абстрактный базовый класс
// (token — по-русски тоже «токен» — объект, выделяемый из строки с
// арифметическим выражением в процессе ее анализа (парсинга);
//	у	нас	будут	два	вида	токенов	—	вещественное	число	и арифметическая
// операция)

{
public:
virtual float getNumber() const = 0;	// чистые виртуальные функции
	virtual wchar_t getOperator() const = 0;
};

class Operator : public Token // класс, представляющий токен «арифметическая операция»
{
private:
	wchar_t oper; // знак арифметической операции (возможные значения: +, –, *, /) 
public:
	Operator(wchar_t op) : oper(op) // конструктор с одним аргументом
	{ }
	wchar_t getOperator() const	// метод выдает знак операции
	{
		return oper;
	}
	float getNumber() const // фиктивная функция (нужна только, чтобы данный класс
	{
		return 0.0f;
	}	// не стал абстрактным, для объектов данного класса
	// не должна вызываться)
};

class Number : public Token // класс, представляющий токен «вещественное число»
{
private:
	float fnum; // вещественное число
public:
	Number(float n) : fnum(n)	// конструктор с одним аргументом
	{ }
	float getNumber() const	// метод выдает значение вещественного числа
	{
		return fnum;
	}
	wchar_t getOperator() const // фиктивная функция (нужна только, чтобы данный класс
	{
		return L'0';

	}	// не стал абстрактным, для объектов данного класса
	// не должна вызываться)
};

class Stack // класс, реализующий стек
{
private:
	Token* atoken[100]; // стек в виде массива указателей на токены
	// (может содержать переменные типов Operator* и Number*)
	int top;	// индекс, указывающий на вершину стека
public:
	Stack()	// конструктор без аргументов
	{
		top = 0;
	}
	void push(Token* var) // поместить токен в стек
	{
		atoken[++top] = var;
	}
	Token* pop()	// забрать токен из стека
	{
		return atoken[top--];
	}
	int gettop() const	// получить индекс, указывающий на вершину стека
	{
		return top;
	}
	bool isNumber() const // метод определяет, является ли токен на вершине стека
	{	// вещественным числом (работает, только если стек не пуст)
	// (возможность RTTI в компиляторе должна быть включена)


		Number* pNum;
		if (pNum = dynamic_cast<Number*>(atoken[top])) return true;

		else
			return false;
	}
};


int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT); Stack s; // создадим стек
	// создадим объекты-токены обоих видов
	Number n1(6.02f), n2(3.333f), n3(75.25f), n4(2.0f), n5(3.14159f);
	Operator plus(L'+'), mult(L'*'), minus(L'-'), div(L'/');

	// вперемешку поместим в стек адреса объектов-токенов обоих видов
	s.push(&n1); s.push(&plus); s.push(&n2);
	s.push(&mult); s.push(&n3); s.push(&plus); s.push(&n4); s.push(&div); s.push(&n5);

	while (s.gettop() > 0) // пока стек не пуст
	{
		// будем извлекать объекты-токены обоих видов из стека и выводить их на экран

			// в зависимости от вида объекта-токена вызываем определенный метод,
			// возвращающий значение токена для вывода на экран 
			if (s.isNumber())
			wcout << s.pop()->getNumber();
else
wcout << s.pop()->getOperator();

// если объект-токен не последний в стеке, вывести пробел для разделения
// токенов на экране
if (s.gettop() > 0) wcout << L' ';
	}
	wcout << endl;

	return 0;

}





10






#include <iostream>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <iomanip> // для манипуляторов setiosflags, setprecision
#include <sstream> // для стандартного класса wstringstream 
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

struct link	// элемент списка
{

	int data;  // данные
	link* next; // указатель на следующий элемент списка
};

class linklist	// класс, представляющий связный список
{
private:
	link* first;	// указатель на первый элемент списка 
public:
	linklist()	// конструктор без аргументов
	{
		first = NULL;
	} // первого элемента пока нет
	linklist(linklist&); // перегруженный копирующий конструктор (прототип)
	~linklist();	// деструктор (прототип)
	void additem(int d); // добавление элемента списка
	void display();	// вывод на экран данных из всех элементов списка
	linklist& operator= (linklist&); // перегруженный оператор присваивания (прототип)

};

linklist::linklist(linklist& li) // перегруженный копирующий конструктор
{
	first = NULL;	// новый связный список пока пуст
	// от копирующего конструктора требуется выделить память под новый связный список

		
		// и перекопировать в этот новый связный список элементы списка-аргумента  li 
	link* current = li.first;	// начинаем с первого элемента списка-аргумента
		while (current)	// пока не достигнут конец списка-аргумента
		{
			additem(current->data); // выделим память под новый элемент нового связного списка
//	и   запишем	в	него	данные   из текущего элемента списка - аргумента
				current = current->next; // перейдем к следующему элементу списка-аргумента
		}

	// Нужно заметить, что в этом цикле мы в списке-аргументе идем от первого элемента
	// к последнему; а в новом связном списке мы идем от последнего к первому (так как
	// добавление элемента происходит в начало списка). В связи с этим в новом связном
	// списке данные будут расположены в обратном порядке по сравнению со списком- аргументом.
	// Однако, в задании к упражнению сказано, что об этом не следует беспокоиться.
}

void linklist::additem(int d) // добавление элемента списка
{
	link* newlink = new link; // выделяем память под новый элемент списка 
	newlink->data = d;	// сохраняем в него данные
	newlink->next = first;	// указатель на следующий элемент списка
	//	теперь	будет	указывать	на	элемент, который
		// до этого был первым
		first = newlink;	// первым теперь стал только что созданный элемент,
		// то есть добавление элементов происходит
		// в начало связанного списка
}

void linklist::display() // вывод на экран данных из всех элементов списка
{
	link* current = first;		// начинаем с первого элемента
	while (current)	// пока указатель на текущий элемент
	{		// не равен NULL (что означает конец списка) 
		wcout << current->data << L' '; // выводим данные
		current = current->next;	// переходим к следующему элементу
	}
	wcout << endl;
}

// деструктор (реализация) 
linklist::~linklist()
{

	link* current = first;		// начинаем с первого элемента 
	while (current)	// пока не конец (NULL) списка
	{
		first = current->next; // первым становится предыдущий элемент
		delete current;	// освобождаем память, занятую текущим элементом
		wcout << L"Элемент списка удалён." << endl; // сообщение (в тестовых целях) 
		current = first;	// теперь текущий элемент тот, который ранее
		// был предыдущим
	}
}

linklist& linklist::operator= (linklist& li) // перегруженный оператор присваивания
{
	// проверка на присваивание самому себе
	if (this == &li) return *this;

	// от оператора присваивания требуется удалить старый связный список, затем
	// выделить память под новый связный список и перекопировать в этот новый связный список
// элементы списка-аргумента li
// удаление старого связного списка
		link* current = first;		// начинаем с первого элемента
	while (current)	// пока не конец (NULL) списка
	{

		first = current->next; // первым становится предыдущий элемент
		delete current;		// освобождаем память, занятую текущим элементом 
		current = first;	// теперь текущий элемент тот, который ранее
		// был предыдущим
	}
	// выделяем память под новый связный список и перекопируем в этот новый связный список
// элементы списка-аргумента
		current = li.first;	// начинаем с первого элемента списка-аргумента
	while (current)		// пока не достигнут конец списка-аргумента
	{

		additem(current->data); // выделим память под новый элемент нового связного  списка


			//	и   запишем	в	него	данные   из текущего элемента списка - аргумента
			current = current->next; // перейдем к следующему элементу списка-аргумента
	}

	// Нужно заметить, что в этом цикле мы в списке-аргументе идем от первого элемента
	// к последнему; а в новом связном списке мы идем от последнего к первому (так как
	// добавление элемента происходит в начало списка). В связи с этим в новом связном

	// списке данные будут расположены в обратном порядке по сравнению со списком- аргументом.
	// Однако, в задании к упражнению сказано, что об этом не следует беспокоиться.

	return *this; // вернуть текущий объект
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);

	// Чтобы иметь возможность вручную удалить (освободить занятую им память) связный
	// список, мы создадим (выделим под него память) один из списков с помощью оператора new;
	// остальные списки мы создадим обычным путем
	linklist* list1 = new linklist; // создаем связный список
	list1->additem(25); // добавляем четыре элемента в список 
	list1->additem(36);
	list1->additem(49); list1->additem(64);

	// выведем список на экран
	wcout << L"list1 = "; list1->display();
	linklist list2(*list1); // тестируем перегруженный копирующий конструктор 
	linklist list3;
	list3 = *list1;	// тестируем перегруженный оператор присваивания

	// удалим первоначальный список 
	delete list1;

	// выводим тестовые списки на экран 
	wcout << L"list2 = "; list2.display(); wcout << L"list3 = "; list3.display();

	// здесь программа завершает свою работу, поэтому автоматически будет
	// выполнено уничтожение объектов list2, list3 класса linklist, при этом будут
	// автоматически запущены деструкторы этих объектов


	return 0;
}






11







#include <iostream>
#include <io.h> // для функции _setmode
#include <fcntl.h> // для константы _O_U16TEXT 
#include <iomanip> // для манипуляторов setiosflags, setprecision
#include <sstream> // для стандартного класса wstringstream 
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

const int LEN = 80; // максимальная длина арифметического выражения (в символах) 
const int MAX = 40; // размер стека

class Token // абстрактный базовый класс
// (token — по-русски тоже «токен» — объект, выделяемый из строки с
// арифметическим выражением в процессе ее анализа (парсинга);
//	у	нас	будут	два	вида	токенов	—	вещественное	число	и арифметическая// операция)

{
public:
virtual float getNumber() const = 0;	// чистые виртуальные функции 
	virtual wchar_t getOperator() const = 0;
};

class Operator : public Token // класс, представляющий токен «арифметическая операция»
{
private:
	wchar_t oper; // знак арифметической операции (возможные значения: +, –, *, /) 
public:
	Operator(wchar_t op) : oper(op) // конструктор с одним аргументом
	{ }
	wchar_t getOperator() const	// метод выдает знак операции
	{
		return oper;
	}
	float getNumber() const // фиктивная функция (нужна только, чтобы данный класс
	{
		return 0.0f;
	}	// не стал абстрактным, для объектов данного класса
	// не должна вызываться)
};

class Number : public Token // класс, представляющий токен «вещественное число»
{
private:
	float fnum; // вещественное число 
public:
	Number(float n) : fnum(n)	// конструктор с одним аргументом
	{ }
	float getNumber() const	// метод выдает значение вещественного числа
	{
		return fnum;
	}
	wchar_t getOperator() const // фиктивная функция (нужна только, чтобы данный класс
	{
		return L'0';
	}	// не стал абстрактным, для объектов данного класса

	// не должна вызываться)
};

class Stack // класс, реализующий стек
{
private:
	Token* atoken[MAX]; // стек в виде массива указателей на токены
	// (может содержать переменные типов Operator* и Number*)
	int top;	// индекс, указывающий на вершину стека
public:
	Stack()	// конструктор без аргументов
	{
		top = 0;
	}
	void push(Token* var) // поместить токен в стек
	{
		atoken[++top] = var;
	}
	Token* pop()	// забрать токен из стека
	{
		return atoken[top--];
	}
	int gettop() const	// получить индекс, указывающий на вершину стека
	{
		return top;
	}
	bool isNumber() const // метод определяет, является ли токен на вершине стека
	{	// вещественным числом (работает, только если стек не пуст)
	// (возможность RTTI в компиляторе должна быть включена)
Number* pNum;
		if (pNum = dynamic_cast<Number*>(atoken[top])) return true;

		else
			return false;
	}
};

class express // класс, представляющий арифметическое выражение
{
private:
	Stack s;	// стек для анализа арифметического выражения
	wchar_t* pStr; // указатель на заданную строку с арифметическим выражением 
	int len;	// длина заданной строки
public:
	express(wchar_t* ptr) // конструктор с одним аргументом
	{
		pStr = ptr;	// запоминаем указатель на заданную строку 
		len = wcslen(pStr); // запоминаем длину заданной строки
	}

	void parse(); // разбор (парсинг) заданной строки с арифметическим выражением
	float solve(); // вычисление арифметического выражения, оставшегося в стеке
};

// разбор (парсинг) заданной строки с арифметическим выражением
// (метод разбивает выражение на токены и добавляет их в стек, вычисляя
// добавленное в стек ранее, после чего в стеке остается простое выражение вида 5+4
// или вида 2+3*5, в котором можно произвести вычисления справа налево одним проходом,
// что и будет сделано в методе express::solve) 
void express::parse()
{
	wchar_t ch;	// символ из заданной строки с арифметическим выражением 
	Token* lastval; // последнее помещенное в стек число (операнд)
	Token* lastop; // последний помещенный в стек знак операции

	float ans;	// для вещественных чисел
	Number* ptrN; // для указателей на токены-числа 
	Operator* ptrO; // для указателей на токены-операции

	// указатель на текущую анализируемую позицию в строке с арифметическим выражением
	// (начинаем анализ с начала этой строки) 
	wchar_t* pCurrent = pStr;

	while (pCurrent[0]) // пока не достигнут конец анализируемой строки
	{
		//	получим	символ	из	текущей	анализируемой	позиции	в	строке	с арифметическим выражением
		ch = pCurrent[0];

		if (ch >= L'0' && ch <= L'9') // если это цифра,
		{

			ans = wcstof(pCurrent, &pCurrent); // получим из строки вещественное число


				//	(указатель pCurrent передвигаем на следующий токен)
			ptrN = new Number(ans);		// выделим память под токен-число
			s.push(ptrN);	// поместим токен в стек
		}
		// если это знак арифметической операции
		else if (ch == L'+' || ch == L'-' || ch == L'*' || ch == L'/')
		{
			if (s.gettop() == 1) // если это первый в выражении знак операции,
			{
				ptrO = new Operator(ch); // выделим память под токен-операцию 
				s.push(ptrO);	// поместим токен в стек
			}
			else // это не первый в выражении знак операции
			{
				lastval = s.pop(); // получаем предыдущее в анализе число-операнд




				

					lastop = s.pop(); // получаем предыдущий в анализе знак операции
					// если наш знак операции * или /, а предыдущий был + или -, то
				if ((ch == L'*' || ch == L'/') &&
				(lastop->getOperator() == L'+' || lastop->getOperator() == L'-'))

				{
					s.push(lastop); // отменяем последние два взятия из стека 
					s.push(lastval);
				}
		else // во всех других случаях
		{
// выполним предыдущую операцию и поместим результат в стек 

				switch (lastop->getOperator())
				{
				case L'+':
					ans = s.pop()->getNumber() + lastval->getNumber(); ptrN = new Number(ans);
					s.push(ptrN); break;
				case L'-':
					ans = s.pop()->getNumber() - lastval->getNumber(); ptrN = new Number(ans);
					s.push(ptrN); break;
				case L'*':
					ans = s.pop()->getNumber() * lastval->getNumber(); ptrN = new Number(ans);
					s.push(ptrN); break;
				case L'/':
					ans = s.pop()->getNumber() / lastval->getNumber(); ptrN = new Number(ans);
					s.push(ptrN); break;
				default: wcout << L"\nНеизвестный   знак   операции\n";
exit(1);


			}
		}
Operator* ptrO = new Operator(ch); // выделим память под токен-операцию

		s.push(ptrO);	// поместим токен в стек
			}

			pCurrent++; // указатель pCurrent передвигаем на следующий токен
		}
		else // если символ не является ни вещественным числом, ни знаком операции
		{
			wcout << L"\nНеразрешенный символ в арифметическом выражении\n";
			exit(1);
		}
	}

}

// вычисление арифметического выражения, оставшегося в стеке
// (после чего стек остается пустым) 
float express::solve()
{
	Token* lastval; // последнее помещенное в стек число (операнд)

	float ans;	// для вещественных чисел
	Number* ptrN; // для указателей на токены-числа

	while (s.gettop() > 1) // пока в стеке не останется результат вычисления
	{	// нашего арифметического выражения,
		lastval = s.pop(); // получим последнее в анализе число-операнд
		switch (s.pop()->getOperator()) // получим последний в анализе знак операции
		{	// выполним операцию и поместим результат в стек
		case L'+':
			ans = s.pop()->getNumber() + lastval->getNumber(); ptrN = new Number(ans);
			s.push(ptrN); break;
		case L'-':
			ans = s.pop()->getNumber() - lastval->getNumber(); ptrN = new Number(ans);
			s.push(ptrN); break;
		case L'*':
			ans = s.pop()->getNumber() * lastval->getNumber(); ptrN = new Number(ans);
			s.push(ptrN); break;
		case L'/':
			ans = s.pop()->getNumber() / lastval->getNumber(); ptrN = new Number(ans);
			s.push(ptrN); break;
		default: wcout << L"\nНеизвестный знак операции\n"; exit(1);
		}
	}

	return s.pop()->getNumber(); // в стеке остался результат вычисления выражения,
	// забираем его и возвращаем; стек остается пустым
}

int main()
{
	// переключение стандартного потока вывода в формат Юникода
	_setmode(_fileno(stdout), _O_U16TEXT);
	// переключение стандартного потока ввода в формат Юникода
	_setmode(_fileno(stdin), _O_U16TEXT);

	wchar_t ans;	// 'д' или 'н'
	wchar_t string[LEN]; // строка с арифметическим выражением для разбора (парсинга)

	wcout << L"Введите арифметическое выражение, например: 2.5+3.0*4/3.148-2.84" L"\nЧисла могут быть вещественными и состоять из нескольких цифр." L"\nНе используйте пробелы и скобки.\n";

	do {
		wcout << L"\nВведите выражение: "; // получаем строку от пользователя (может содержать пробелы),
					ws(wcin); wcin.get(string, LEN);	// предварительно убрав из потока wcin ведущие пробельные символы
					// (пробелы, переводы строки, табуляция)

		express* eptr = new express(string); // создаем объект-выражение для разбора

		eptr->parse();	// выполняем разбор (парсинг) выражения
		//	(только	на этом этапе выдаем ошибку по поводу выражении, а не раньше)


		//	пробелов	в

			wcout << L"Результат вычисления выражения: "
			<< eptr->solve();		// получаем результат вычисления delete eptr;	// удаляем объект-выражение
		wcout << L"\nЕще одно выражение (д/н)? "; wcin >> ans;
	} while (ans == L'д');

	return 0;
}


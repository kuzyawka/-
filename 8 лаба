4


#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

const int SAL = 3; //кол-во месяцев

class Sales // класс, представляющий сведения о выручке от продаж за 3 месяца
{
private:
	float sales[SAL]; // массив из *SAL* чисел, каждое из которых представляет
	// собой выручку от продаж за один месяц
public:
	void getdata()
	{
		for (int j = 1; j <= SAL; j++)
		{
			cout << "\nВведите выручку от продаж в " << j << " месяце: ";
			cin >> sales[j];
		}
	}
	void putdata()const
	{
		for (int j = 1; j <= SAL; j++)
		{
			cout << "\nВыручка от продаж в " << j << " месяце: ";
			cout << sales[j];
		}
	}
};

class Publication // класс, представляющий издание (результат работы издательской компании)
{
private:
	string name; //название издания 
	float price; //цена экземпляра
public:
	void getdata() //Ввод информации
	{
		cout << "Введите название книги: "; cin >> name; cout << "\nЦена: "; cin >> price;
	}

	void putdata()const
	{
		cout << "\nназвание книги: " << name << "\nцена: " << price;
	}
};

class Book : private Sales, private Publication // класс, представляющий бумажную книгу
// (производный от класса, представляющего издание, и от класса со сведениями о выручке от продаж)
{
private:
	int pages; // количество страниц в книге 
public:
	void getdata()
	{
		Publication::getdata();
		cout << "\nвведите кол-во страниц в книге: "; cin >> pages;
		Sales::getdata();
	}
	void putdata()const
	{
		Publication::putdata();
		cout << "\nкол-во страниц в книге: " << pages;
		Sales::putdata();
	}
};
// класс, представляющий аудиокнигу
// (производный от класса, представляющего издание, и от класса со сведениями о выручке от продаж)
class Type : private Sales, private Publication
{
private:
	float time; // время проигрывания аудиокниги в минутах 
public:
	void getdata()
	{
		Publication::getdata();
		cout << "\nвведите время проигрывания аудиокниги в минутах: "; cin >> time;
		Sales::getdata();
	}
	void putdata()const
	{
		Publication::putdata();
		cout << "\nвремя проигрывания аудиокниги в минутах: " << time;
		Sales::putdata();
	}
};
// класс, представляющий издание (книгу) на оптическом диске
// (производный от класса, представляющего издание, и от класса со сведениями о выручке от продаж)
class Disk : private Sales, private Publication
{
private:
	enum etype { CD, DVD }; // тип оптического диска: CD или DVD 
public:
	void getdata()
	{
		etype t_disk;
		char type;
		Publication::getdata();
		cout << "\nТип диска (c/d): "; cin >> type;
		if (type = 'c')
			t_disk = CD;
		else t_disk = DVD;

		Sales::getdata();
	}
	void putdata()const
	{
		Publication::putdata();
		etype t_disk;
		char type;
		cout << "\nТип диска: ";
		if (t_disk = CD)
			cout << "CD";
		else
			cout << "DVD";
		Sales::putdata();
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	// создадим объекты для тестирования соответствующих классов
	Book bok; //книга
	Type tp; //аудиокнига
	Disk dk; //оптический диск
	// получим от пользователя данные для тестируемых объектов 
	bok.getdata();
	tp.getdata();
	dk.getdata();
	// выведем на экран данные тестируемых объектов

	cout << "\n" << "класс Книга:: "; bok.putdata();
	cout << "\n" << "класс Аудиокнига: "; tp.putdata();
	cout << "\n" << "класс Диск: "; dk.putdata();
	cout << endl; system("pause");
};




5



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

class Employee //класс Работник
{
protected:
	string name; unsigned int number;
public: void set()
{
	
	cout << "Введите имя: "; cin >> name; 
	cout << "Введите номер: "; cin >> number;
}
	  void get()
	  {
		  cout << "Имя: " << name << endl; cout << "Номер: " << number << endl;
	  }
};
class Employee_ver2 : public Employee
{
protected: //период оплаты работы
	enum period { hourly, weekly, monthly }; period per;
double compensation; public:
	void set_ver2()
	{
		char sb = '0'; set();
		cout << "Введите зарплату: "; cin >> compensation;
		cout << "Введите период оплаты работы служащего (ch, n или m): "; cin >> sb; 
		switch (sb)
		{
		case 'ch': per = hourly; break;
		case 'n': per = weekly; break; 
		case 'm': per = monthly; break;
		default:
			cout << "Нет такого периода! Вводите данные заново\n";

			cin.get(); set_ver2(); break;
		}
	}
	void get_ver2()
	{
		get();
		cout << "Зарплата = " << compensation << endl; cout << "Период оплаты работы служащего: ";
		switch (per)
		{
		case hourly: cout << "почасовая\n"; break; 
		case weekly: cout << "понедельная\n"; break;
		case monthly: cout << "помесячная\n"; break;
		}
	}
};

int main()
{
	setlocale(LC_ALL, "Russian"); Employee_ver2 emp; emp.set_ver2(); emp.get_ver2();
	cout << endl;

}




6





#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

const int LIMIT = 100; // размер массива

// оригинальный класс, реализующий «безопасный» массив 
class safearray
{
private:
int arr[LIMIT]; 
public:
	int& operator[] (int n)
	{
		if (n < 0 || n >= LIMIT)
		{
			cout << "Ошибочный индекс!"; exit(1);
		}
		return arr[n];
	}
};

// новый класс, производный от оригинального класса safearray, реализующий

// возможность определения границ массива 
class safehilo : public safearray
{
private:
	int lowerbound; // нижняя граница индекса массива 
	int upperbound; // верхняя граница индекса массива
public:
	// конструктор с двумя аргументами
	safehilo(int low, int up) : lowerbound(low), upperbound(up)
	{
		// проверим заданные пользователем границы на ошибки
		if (lowerbound > upperbound)
		{
			cout << "Ошибка! Верхняя граница индекса массива не может быть меньше нижней.\n"; exit(1);
		}
		if (upperbound - lowerbound >= LIMIT)
		{
			cout << "Ошибка! В массиве не может быть больше " << LIMIT << L" элементов.\n"; exit(1);
		}
	}

	int& operator[] (int n)
	{
		if (n < lowerbound || n > upperbound)
		{
			cout << "Ошибочный индекс!"; exit(1);
		}

		return safearray::operator[] (n - lowerbound);
		// выражение (n - lowerbound) отображает заданный пользователем индекс в реальный
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");
	int low, up; // для верхней и нижней границ индекса массива

	cout << "Введите нижнюю границу индекса массива : "; cin >> low; 
	cout << "Введите верхнюю границу индекса массива: "; cin >> up;

	safehilo sa1(low, up);

	// задаем значения элементов
	 for (int j = low; j <= up; j++)
	// используем функцию слева от знака присваивания (=) 
		 sa1[j] = j * 10;

	// показываем элементы

	for (int j = low; j <= up; j++)
	{
		// используем функцию справа от знака присваивания (=)
		int temp = sa1[j];
		cout << "Элемент " << j << " равен " << temp << endl;
	}

	return 0;
}





7




#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

class Counter // класс, реализующий счетчик и операцию его инкремента (в префиксной форме)
{
protected:	// заметьте, что тут не следует использовать private
	int count;		// счетчик
public:
	Counter() : count(0)	// конструктор без параметров
	{ }
	Counter(int c) : count(c)	// конструктор с одним параметром
	{ }
	unsigned int get_count() const // получение значения счетчика
	{
		return count;
	}
	Counter operator++()	// увеличить значение счетчика (префиксная форма)
	{
		return Counter(++count);
	}
};
// класс, производный от класса Counter (счетчик), добавляющий операцию
// декремента счетчика (в префиксной форме) 
class CountDn : public Counter
{
public:
	CountDn() : Counter()	// конструктор без параметров
	{ }
	CountDn(int c) : Counter(c)	// конструктор с одним параметром
	{ }
	CountDn operator--() // уменьшить значение счетчика(префиксная форма)
	{
		return CountDn(--count);
	}
};
// новый класс, добавляющий в программу инкремент и декремент счетчика
// в постфиксной форме 
class Postfix : public CountDn
{
public:

	Postfix() : CountDn() // конструктор без параметров
	{}
	Postfix(int c) : CountDn(c) // конструктор с одним параметром
	{}
	Postfix operator++(int) // инкремент (увеличение счетчика) в постфиксной форме
	{
		return Postfix(count++);
	}
	Postfix operator--(int) // декремент (уменьшение счетчика) в постфиксной форме
	{
		return Postfix(count--);
	}
};

int main()
{
	setlocale(LC_ALL, "Russian"); Counter* c1 = new Postfix;
	cout << "\nc1 = " << c1->get_count();
	++* c1; ++* c1; ++* c1;
	cout << "\nc1 = " << c1->get_count(); CountDn* c2 = new Postfix;
	cout << "\nc2 = " << c2->get_count();
	--* c2; --* c2; --* c2;
	cout << "\nc2 = " << c2->get_count(); Postfix c3, c4(10);
	c3 = c4++;
	c3.get_count(); c3 = c4++;
	c3.get_count(); cout << endl; cin.get(); return 0;
}





8



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

class String // класс, представляющий строку (массив символов)
{
protected:
	enum { SZ = 80 }; // максимальный размер строки (нестандартный синтаксис) 
	char str[SZ]; // сама строка
public:
	String() // конструктор без параметров
	{
		str[0] = '\0';
	}
	String(char s[]) //конструктор с одним параметром
	{
		strcpy_s(str, s);

	}
	void display() const // показ строки на экране
	{
		cout << str;
	}
	operator char* () // преобразование объекта класса String к обычной строке (массив типа char)
	{
		return str;
	}
};
class Pstring : public String // класс, представляющий «защищенную» строку (с защитой от переполнения массива символов)
{
public:
	Pstring(char s[]); // конструктор с одним параметром
};
Pstring::Pstring(char s[]) //конструктор для Pstring
{
	if (strlen(s) > SZ - 1)
	{
		for (int j = 0; j < SZ - 1; j++) 
			str[j] = s[j];
		str[SZ - 1] = '\0';
	}
	else
	{
		String(s);
	}
}
// новый класс, добавляющий три метода, с помощью которых можно выделить часть строки и
// присвоить ее другой строке 
class Pstring2 : public Pstring
{
public:
	string left(unsigned int amount) // метод извлекает из заданной строки n символов слева, записывает их в строку
	{
		string temp = "";
		for (int i = 0; i < amount; i++)
		{
			temp += str[i];
		}
		return temp;
	}
	// метод извлекает из заданной строки n символов справа, записывает их в строку 
	string right(unsigned int amount)
	{
		string temp = "";
		int len = strlen(str);

		for (int i = len - amount; i < len; i++)
		{
			temp += str[i];
		}
		return temp;
	}
	string mid(unsigned int amount, unsigned int elementary)// метод извлекает из заданной строки n символов, начиная с позиции mid, записывает
	// их в строку
	{
		string temp = "";
		for (int i = elementary - 1; i < elementary - 1 + amount; i++)
		{
			temp += str[i];
		}
		return temp;
	}
};
int main()
{
	setlocale(LC_ALL, "Russian");
	cout << endl;
}





9




#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;

class date // класс, представляющий дату
{
private:
	int day;   // день 
	int month; // месяц 
	int year; // год
public:
	// метод для получения данных класса от пользователя с клавиатуры
	void get()
{
	char slash; // для косой черты
	cout << "Введите день, месяц и год через косую черту (/): ";
	cin >> day >> slash >> month >> slash >> year;
}
// константный метод выводит значения полей на экран 
void display() const
{
	cout << day << "/" << month << "/" << year;
}
};

// класс, представляющий издание (результат работы издательской компании) 
class publication

{
private:
	wstring title; // название издания
	float price; // цена экземпляра издания
public:
	void getdata()
	{
		cout << "\n введите название издания: "; getline(ws(wcin), title);
		cout << " введите цену экземпляра издания: "; cin >> price;
	}
	void putdata() const
	{
		wcout << "\n название издания: " << title;
		cout << "\n цена экземпляра издания: " << price << endl;
	}
};

// новый класс, представляющий издание (результат работы издательской компании)
// (производный от старого класса, представляющего издание) 
class publication2 : public publication
{
private:
	date pub_date; // дата публикации издания 
public:
	void getdata()
	{
		publication::getdata();
		cout << " введите дату публикации издания:\n "; pub_date.get();
	}
	void putdata() const
	{
		publication::putdata();
		cout << L" дата публикации издания: "; pub_date.display(); wcout << endl;
	}
};

//	класс,	представляющий	бумажную	книгу	(производный	от	нового	класса, представляющего издание)
class book : public publication2
{
private:
	int pages; // количество страниц в книге
public:
	void getdata()
	{
		publication2::getdata();
		cout << " введите количество страниц в книге: "; cin >> pages;
	}
	void putdata() const
	{
		publication2::putdata();

		cout << " количество страниц в книге: " << pages << endl;
	}
};

// класс, представляющий аудиокнигу (производный от нового класса, представляющего издание)
class tape : public publication2
{
private:
	float playing_time; // время проигрывания аудиокниги в минутах
public:
	void getdata()
	{
	publication2::getdata();
	cout << " введите время проигрывания аудиокниги в минутах: ";
	cin >> playing_time;
}

		void putdata() const
	{
		publication2::putdata();
		cout << " время проигрывания аудиокниги в минутах: " << playing_time << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	// создадим объекты для тестирования соответствующих классов
	book b1; // бумажная книга
	tape t1; // аудиокнига

	// получим от пользователя данные для тестируемых объектов
	cout << "Ввод данных опубликованной бумажной книги"; b1.getdata(); 
	cout << "\nВвод данных опубликованной аудиокниги"; t1.getdata();

	// выведем на экран данные тестируемых объектов
	cout << "\nДанные опубликованной бумажной книги"; b1.putdata(); 
	cout << "\nДанные опубликованной аудиокниги"; t1.putdata();

	return 0;

}






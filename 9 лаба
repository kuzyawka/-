5



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
// прототипы функций
void addarrays(float*, float*, float*, int); void display(float*, int);

int main()
{
	setlocale(LC_ALL, "Russian");

	const int SIZE = 7; // размер массивов
	// три заданных массива
	float arr1[SIZE] = { 23.1f, 5.67f, 0.32f, 4.0f, 73.213f, 3.5f, 890.1f }, arr2[SIZE] = { 11.23f, 7.32f, 444.0f, 32.12f, 79.3f, 5.321f, 45.09f }, arr3[SIZE];

	// складываем поэлементно массивы arr1 и arr2, результаты сохраняем в arr3 
	addarrays(arr1, arr2, arr3, SIZE);

	// выведем исходные массивы и результат сложения на экран 
	cout << "Первый массив = "; display(arr1, SIZE); cout << endl; cout << "Второй массив = "; display(arr2, SIZE); cout << endl;
	cout << "Результат сложения = "; display(arr3, SIZE); cout << endl;

	return 0;
}

// функция складывает поэлементно два массива и сохраняет результаты в элементах
// третьего массива (N — размер массивов)
void addarrays(float* a1, float* a2, float* a3, int N)
{
	for (int j = 0; j < N; j++)

		*(a3 + j) = *(a1 + j) + *(a2 + j);
}

// функция выводит элементы массива на экран
void display(float* a, int N)
{
	for (int j = 0; j < N; j++)
		cout << *(a + j) << ((j != N - 1) ? ", " : "");
}




6



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
int compwcs(const char*, const char*); // прототип функции
int main()
{
	setlocale(LC_CTYPE, "Russian");
	const char* str1, * str2; // строки для сравнения

	// При сортировке фамилий по возрастанию (то есть по алфавиту) фамилии
	// отсортируются так (фамилия выше (ближе к началу алфавита) считается меньшей):
	// 1. Petrov
	// 2. Архангельский
	// 3. Петров
	// 4. Петровский
	// 5. Сидоров
	// 6. Яковлев
	// 7. сидоров (с прописной буквы)

	str1 = "Сидоров"; str2 = "Петровский"; // результат: 1 (str1 > str2)
	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2) << endl;

	str1 = "Петровский"; str2 = "Сидоров"; // результат: -1 (str1 < str2)
	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2) << endl;

	str1 = "Петров"; str2 = "Петров"; // результат: 0 (str1 == str2)
	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2) << endl;

	str1 = "Петров"; str2 = "Петровский"; // результат: -1 (str1 < str2)
	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2) << endl;

	str1 = "Петровcкий"; str2 = "Петров"; // результат: 1 (str1 > str2)
	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2) << endl;

	// Предположим, оператор ошибся и ввел фамилию с прописной буквы: "сидоров". Такая фамилия
		// в списке станет после всех фамилий, введенных с ЗАГЛАВНОЙ буквы, так как коды
		// прописных букв в Юникоде больше, чем коды ЗАГЛАВНЫХ

		str1 = "сидоров"; str2 = "Яковлев"; // результат: 1 (str1 > str2)

	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2)
		<< endl;

	// Предположим, оператор ввел одну из фамилий латиницей: "Petrov". В списке фамилий
	// фамилии, введенные латиницей, станут выше, чем фамилии, введенные кириллицей, так как
	// коды латинских букв в Юникоде меньше, чем коды кириллических

	str1 = "Petrov"; str2 = "Архангельский"; // результат: -1 (str1 < str2)
	cout << '"' << str1 << "\", \"" << str2 << "\", результат: " << compwcs(str1, str2) << endl;

	return 0;
}

// функция сравнивает две заданные строки и возвращает результат сравнения:
// 0 — строки равны;
// -1 — первая строка меньше второй;
// 1 — первая строка больше второй
int compwcs(const char* s1, const char* s2)
{
	while (*s1 && *s2)	// пока не достигнут конец ни одной из строк,
	{	// сравниваем их посимвольно:
		if (*s1 > *s2)	// если символ первой строки больше символа второй, 
			return 1;		// возвращаем 1 (первая строка больше второй)
		else if (*s1 < *s2) // если символ первой строки меньше символа второй,
			return -1;	// возвращаем -1 (первая строка меньше второй)
		s1++; s2++;	// переходим к следующему символу в каждой из строк
	}

	// если программа дошла сюда, значит был достигнут конец либо одной из строк,
	// либо конец обеих строк одновременно, при этом короткая строка полностью
	// совпадает с началом длинной

	if (!*s1 && !*s2)	// если строки равны по длине и совпадают посимвольно, 
		return 0;		// возвращаем 0 (строки равны)
	else if (!*s1)	// если первая строка короче, а посимвольно строки совпадают,
		return -1;		// возвращаем -1 (первая строка меньше второй)
	else		// если вторая строка короче, а посимвольно строки совпадают, 
		return 1;
}	// возвращаем 1 (первая строка больше второй)




7



#include <iostream>
#include <iomanip>
#include <ctype.h>
#include <string>
#include <cmath>
#include <ctime>
#include <cstdlib>
using namespace std;
class person // класс, представляющий человека
{
protected:
	wstring name; // имя человека 
	float salary; // зарплата человека
public:

	void setData()	// получение от пользователя данных объекта
	{
		cout << " введите имя: "; wcin >> name;
		cout << " введите зарплату: "; cin >> salary;
	}
	void printData() const // вывод на экран данных объекта
	{
		setlocale(LC_ALL, "Russian");
		wcout << endl << " Umya: " << name; cout << endl << " зарплата: " << salary;
	}
	float getSalary() const // возврат поля, содержащего зарплату человека
	{
		return salary;
	}
};

int main()
{
	setlocale(LC_ALL, "Russian");

	void salsort(person**, int); // прототип функции сортировки
	person* persPtr[100];	// массив указателей на объекты класса «человек» 
	int n = 0;	// количество людей в массиве
	char choice;	// хранит выбор пользователя ('д'/'н' — «да»/«нет»)

	// создадим список объектов класса «человек», указатели на которые будем
	// хранить в массиве указателей persPtr
	do
	{
		persPtr[n] = new person;	// создаем новый объект cout << "Субъект " << n << endl;
		persPtr[n]->setData();		// получаем от пользователя данные человека 
		n++;	// увеличение счетчика объектов
		cout << "Продолжаем ввод (y/n)? "; // спрашиваем, закончен ли ввод
		cin >> choice;
	} while (choice == 'y');

	cout << "\nНеотсортированный список:"; // выведем полученный от пользователя 
	for (int j = 0; j < n; j++)	// список объектов класса person,
	{		// указатели на которые содержатся в 
		cout << endl << "Субъект " << j; // массиве persPtr 
		(*(persPtr + j))->printData();
	}
	cout << endl;

	salsort(persPtr, n); // отсортируем указатели на объекты класса person
	// в массиве указателей persPtr

	cout << "\nОтсортированный список:"; // выведем тот же список объектов класса 
	for (int j = 0; j < n; j++)	// person после сортировки
	{

		cout << endl << "Субъект " << j; (*(persPtr + j))->printData();
	}
	cout << endl;

	return 0;
}

// функция реализует упорядочивание элементов массива по возрастанию
// (используется «сортировка методом пузырька», по-английски «bubble sort»)
// pp — указатель на массив указателей на объекты класса person;
// n — количество указателей в массиве
void salsort(person** pp, int n)
{
	for (int j = 0; j < n - 1; j++)	// внешний цикл
		for (int k = j + 1; k < n; k++) // внутренний цикл
		// если первый объект больше второго (сравниваются зарплаты людей),
			if ((*(pp + j))->getSalary() > (*(pp + k))->getSalary())
		{
				person* tempptr = *(pp + j); // то меняем указатели на них местами
				*(pp + j) = *(pp + k);	// в массиве указателей
				*(pp + k) = tempptr;

		}
}




8




